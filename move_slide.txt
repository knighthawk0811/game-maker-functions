/// @function										list_has_solid(_ds_list);
/// @param {Id.DsList}				_ds_list		The list of objects to test
/// @description									Check if any of a DS List of object references are solid
function list_has_solid(_ds_list) 
{
	var _solid = false;
	var _i = ds_list_size(_ds_list) - 1;
	while(_i >= 0)
	{
		//show_debug_message("object: {0}", _ds_list[| _i]);
		if(instance_exists( _ds_list[| _i]) && _ds_list[| _i].solid)
		{
			_solid = true;
			break;
		}
		_i--;
	}
	return _solid;	
}

/// @function													move_contact(_direction, _max_distance, _object, _step);
/// @param {Real}							_direction			The direction you want to move in
/// @param {Real}							_max_distance		The distance you want to move
/// @param {Asset.GMObject, Array, String}	_object				The Object you want to not collide with
/// @param {Real}							_step				How many pixels per step, default 1
/// @description												like move_contact_solid, but with any object or object type
function move_contact(_direction, _max_distance, _object = "solid", _step = 1) 
{	
	//will use later to see if we actually moved
	var _current_x = x
	var _current_y = y
		
	//get x,y, components
	var _movex = lengthdir_x(_max_distance, _direction)
	var _movey = lengthdir_y(_max_distance, _direction)
	
	
	//prepare the step
	if(_step < 1)
	{
		_step = 1;	
	}
	if(_step > max(abs(_movex),abs(_movey)))
	{
		_step = max(abs(_movex),abs(_movey))
	}
		
	var _moved = false;
	
	//collision stuff
	var _collision_list = ds_list_create();
	//ds_list_clear(_collision_list);
	var _collision_count = 0;
	var _solid = false;
	if(_object == "solid")
	{
		_solid = true;
		_object = all;
	}
		
	//try to move all the way
	//if collision then 
	//try to move as far in x and y before hitting the object
	//use a percentage of the movement values and decrement by 5%
	for(var i = 1; i < abs(_max_distance); i += _step)
	{
		//move by 1 pixel
		var _dx = sign(_movex) * ceil(max(0, abs(_movex) - i ));
		var _dy = sign(_movey) * ceil(max(0, abs(_movey) - i ));
		
		ds_list_clear(_collision_list);
		_collision_count = instance_place_list(x + _dx, y + _dy, _object, _collision_list, true);
		if( _collision_count == 0 || (_solid && !list_has_solid(_collision_list)) )
		{			
			x += _dx;
			y += _dy;
			break;
		}
	}
	
	//have we actually moved?
	if(x != _current_x || y != _current_y)
	{
		_moved = true;
	}
	
	return _moved;
}


/// @function													move_slide(_direction, _max_distance, _object, _wide);
/// @param {Real}								_direction		The Object you want to move away from
/// @param {Real}								_max_distance	The distance you want to move
/// @param {Asset.GMObject, Array, String}		_object			The Object you want to not collide with
/// @description												like move_contact_solid, but with any object or object type
function move_slide(_direction, _max_distance, _object = "solid")
{
	//will use later to see if we actually moved
	var _current_x = x
	var _current_y = y
	
	//use trig to find the x,y portion of movement
	//dcos, dsin will convert radians and degrees for us
	var _dx =  _max_distance * dcos(_direction)
	var _dy = -_max_distance * dsin(_direction)
	
	//can move normally?	
	var _moved_h = move_contact(0, _dx, _object);
	var _moved_v = move_contact(270, _dy, _object);
	var _moved = _moved_h || _moved_v;
	
	//slide?
	//if we aren't moving then maybe we need to slide on a ramp		
	if(!_moved)
	{
		//temp variables in case we can move in multiple planes they should cancel each other out in the end
		var _dx_new = 0;
		var _dy_new = 0;
		
		var _solid = false;
		if(_object == "solid")
		{
			_solid = true;
			_object = all;
		}
		
		//do horizontal movement
		if(_dx != 0)
		{
			//try slide up?	
			if(x == _current_x and y == _current_y)
			{
				for(var i = abs(_dx); i > 0; i--) 
				{
					var _slide_x = i * sign(_dx);
					var _slide_y = _dx * .7;
					if(_solid)
					{						
						//checking for solid objects requires building a list
						//then checking each object in the list if it is solid
						var _collision_list = ds_list_create();
						ds_list_clear(_collision_list);
						instance_place_list(x + _slide_x, y - _slide_y, _object, _collision_list, true);
						if( _solid && !list_has_solid(_collision_list) )
						{
							_dx_new += _slide_x;
							_dy_new -= _slide_y;
							break;
						}
					}
					else
					{
						//moving toward an object or array of objects
						if( !place_meeting(x + _slide_x, y - _slide_y, _object) )
						{
							_dx_new += _slide_x;
							_dy_new -= _slide_y;
							break;
						}
						
					}
				}
			}
			//try slide down?			
			if(x == _current_x and y == _current_y)
			{
				for(var i = abs(_dx); i > 0; i--) 
				{			
					var _slide_x = i * sign(_dx);
					var _slide_y = _dx * .7;
					if(_solid)
					{						
						//checking for solid objects requires building a list
						//then checking each object in the list if it is solid
						var _collision_list = ds_list_create();
						ds_list_clear(_collision_list);
						instance_place_list(x + _slide_x, y + _slide_y, _object, _collision_list, true);
						if( _solid && !list_has_solid(_collision_list) )
						{
							_dx_new += _slide_x;
							_dy_new += _slide_y;
							break;
						}
					}
					else
					{
						//moving toward an object or array of objects
						if( !place_meeting(x + _slide_x, y + _slide_y, _object) )
						{
							_dx_new += _slide_x;
							_dy_new += _slide_y;
							break;
						}
						
					}
				}
			}
		} 
		else 
		{ 
			//0 == no movement 
		}
	
		//do vertical movement
		if(_dy != 0)
		{
			//try slide right?	
			if(x == _current_x and y == _current_y)
			{
				for(var i = abs(_dy); i > 0; i--) 
				{		
					var _slide_x = _dy * .7;
					var _slide_y = i * sign(_dy) * .7;
					if(_solid)
					{						
						//checking for solid objects requires building a list
						//then checking each object in the list if it is solid
						var _collision_list = ds_list_create();
						ds_list_clear(_collision_list);
						instance_place_list(x + _slide_x, y + _slide_y, _object, _collision_list, true);
						if( _solid && !list_has_solid(_collision_list) )
						{
							_dx_new += _slide_x;
							_dy_new += _slide_y;
							break;
						}
					}
					else
					{
						//moving toward an object or array of objects
						if( !place_meeting(x + _slide_x, y + _slide_y, _object) )
						{
							_dx_new += _slide_x;
							_dy_new += _slide_y;
							break;
						}
						
					}
				}
			}
			//try slide left?
			if(x == _current_x and y == _current_y)
			{
				for(var i = abs(_dy); i > 0; i--) 
				{		
					var _slide_x = _dy * .7;
					var _slide_y = i * sign(_dy) * .7;
					if(_solid)
					{						
						//checking for solid objects requires building a list
						//then checking each object in the list if it is solid
						var _collision_list = ds_list_create();
						ds_list_clear(_collision_list);
						instance_place_list(x - _slide_x, y + _slide_y, _object, _collision_list, true);
						if( _solid && !list_has_solid(_collision_list) )
						{
							_dx_new -= _slide_x;
							_dy_new += _slide_y;
							break;
						}
					}
					else
					{
						//moving toward an object or array of objects
						if( !place_meeting(x - _slide_x, y + _slide_y, _object) )
						{
							_dx_new -= _slide_x;
							_dy_new += _slide_y;
							break;
						}
						
					}
				}
			}
		} 
		else 
		{ 
			//0 == no movement 
		}	
		x += _dx_new;
		y += _dy_new;
	}
}
